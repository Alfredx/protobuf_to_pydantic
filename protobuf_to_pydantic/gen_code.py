import inspect
from enum import IntEnum
from typing import Optional, Set, Tuple, Type

from pydantic import BaseModel


def _pydantic_model_to_py_code(model: Type[BaseModel]) -> Tuple[Set[str], Set[str], Set[str]]:
    import_set: Set[str] = {"from pydantic import BaseModel"}
    depend_set: Set[str] = set()
    class_str: str = f"class {model.__name__}(BaseModel):\n"
    for key, value in model.__fields__.items():
        value_type = value.type_
        if value.type_.__module__ != "builtins":
            if issubclass(value.type_, IntEnum):
                import_set.add("from enum import IntEnum")
                depend_set_str = f"class {value.type_.__name__}(IntEnum):\n"
                for enum_name, enum_value in value.type_.__members__.items():
                    depend_set_str += " " * 4 + f"{enum_name} = {enum_value.value}\n"
                depend_set.add(depend_set_str)
            else:
                # It is not necessary to consider other types since
                # it is converted from the message object generated by protobuf
                value_type = model.__annotations__[key]
        import_set.add(f"from {value.field_info.__module__} import {value.field_info.__class__.__name__}")
        # Introduce the corresponding class for FieldInfo's properties
        for k, v in value.field_info.__repr_args__():
            value_module = inspect.getmodule(v)
            if not value_module:
                continue
            if value_module.__name__ == "builtins":
                continue
            if inspect.isclass(v):
                class_name: str = v.__name__
            else:
                class_name = v.__class__.__name__
            if str(v) == "PydanticUndefined":
                class_name = "Undefined as PydanticUndefined"
            import_set.add(f"from {value_module.__name__} import {class_name}")
        class_str = class_str + " " * 4 + f"{key}: {value_type.__name__} = {value.field_info.__repr__() }\n"
    return import_set, depend_set, {class_str}


def pydantic_model_to_py_code(
    *model: Type[BaseModel],
    customer_import_set: Optional[Set[str]] = None,
    customer_depend_set: Optional[Set[str]] = None,
    customer_class_set: Optional[Set[str]] = None,
) -> str:
    """
    BaseModel objects into corresponding Python code
    (only protobuf-generated pydantic.BaseModel objects are supported, not overly complex pydantic.BaseModel)
    """
    import_set: Set[str] = customer_import_set or set()
    depend_set: Set[str] = customer_depend_set or set()
    class_set: Set[str] = customer_class_set or set()
    for _model in model:
        _import_set, _depend_set, _class_set = _pydantic_model_to_py_code(_model)
        if _import_set:
            import_set.update(_import_set)
        if _depend_set:
            depend_set.update(_depend_set)
        if _class_set:
            class_set.update(_class_set)

    content_str: str = "\n".join(sorted(import_set))
    if depend_set:
        content_str += "\n\n"
        content_str += "\n".join(sorted(depend_set))
    if class_set:
        content_str += "\n\n"
        content_str += "\n\n".join(sorted(class_set))

    try:
        import isort
    except ImportError:
        pass
    else:
        content_str = isort.code(content_str)

    try:
        import autoflake
    except ImportError:
        pass
    else:
        content_str = autoflake.fix_code(content_str)

    # TODO Waiting for black development API
    # https://github.com/psf/black/issues/

    return content_str
